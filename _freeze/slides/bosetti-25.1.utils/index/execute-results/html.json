{
  "hash": "25a34edbe7a1184bb407b03f129478ab",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The `adas.utils` package\"\nsubtitle: \"Design of Experiments, the tidy way\"\ndate: 2025-05-30\ndate-format: \"rtug::25.1, YYYY-MM-DD\"\nauthor: Paolo Bosetti\ninstitute: University of Trento\ntitle-slide-attributes:\n  data-background-image: /images/logo.png\n  data-background-size: 20%\n  data-background-position: top center\n  data-background-repeat: no-repeat\ndraft: false\ncategories: [packages, meeting, rtug::25.1]\nformat: \n  revealjs:\n    width: 1280\n    height: 720\n    margin: 0.1\n    slide-number: true\n    output-location: column\n    code-line-numbers: true\n    code-annotations: below\n    preview-links: auto\n    theme: [default, ../slides.scss]\n    chalkboard: true\n    footer: \"RTUG --- [https://rtug.unitn.it/slides.html](/slides.html)\"\n    fig-width: 5\n    fig-height: 4\n    fig-dpi: 300\n    touch: true\n    email-obfuscation: javascript\n    pdf-separate-fragments: true\n    link-external-icon: true\n    lang: en-EN\nabstract: |\n  We are here presenting the `adas.utils` package, a collection of functions for the design of experiments, the tidy way.\n---\n\n\n\n\n# {{< bi list-task >}} Contents\n\n::: columns\n:::{.column width=66%}\n* Design of Experiments (*DoE*) and factorial plans\n* How to do DoE in vanilla R\n* How to do DoE with the `adas.utils` package\n* Alternatives\n* Future developments\n:::\n\n:::{.column width=33%}\n![](/posts/004-adas.utils/hypercube.jpg)\n:::\n:::\n\n## Design of Experiments and factorial plans\n\n::: columns\n:::{.column width=66%}\n* Design of Experiments (*DoE*) is a collection of statistical techniques to plan and analyze **industrial** experiments\n* Predictors are typically many (10 or more), and can be continuous or categorical\n* Often a first-order model is enough\n* Fitting a **response surface** on a multidimensional grid can be costly\n\nDoE aims at getting the [most information]{.bgreen} from a [minimum of experiments]{.bblue}\n:::\n\n:::{.column width=34%}\n![](https://m.media-amazon.com/images/I/81zdcVeRwRL._SY385_.jpg){width=80% fig-align=center}\n:::\n:::\n\n::: aside\n{{< bi book >}} See the famous \"Design and Analysis of Experiments\", by Douglas C. Montgomery, 10th edition, Wiley, 2020. \n:::\n\n## DoE in brief\n\n::: columns\n:::{.column width=66%}\n* Plan for a grid of treatments (*factorial plan*) in the $n$-hyperspace, where $n$ is the number of predictors, or **process parameters**\n* The FP can be optimized, sacrificing completeness for efficiency (*Fractional Factorial Plans*)\n* The FP must be [randomized]{.bgreen}, to reduce bias due to systematic errors\n* The FP can be [non-replicated]{.bgreen}, to further reduce costs (*Daniel's method*)\n* The FP can be [augmented]{.bgreen}, to add new treatments to an existing plan (*Augmented Factorial Plans*)\n* We use [coded units]{.bgreen} (i.e. normalized to $[-1,1]$)\n:::\n\n:::{.column width=34%}\n![2 factors CCD](CCD2.png){width=60% fig-align=center}\n\n![3 factors CCD](CCD3.png){width=60% fig-align=center}\n:::\n:::\n\n\n## Simple example in vanilla R\n\nCreate a non-replicated **full factorial plan** with three factors, two levels each ($2^3$):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make the grid\nfp <- expand.grid(\n  A=c(-1,1), \n  B=c(-1,1), \n  C=c(-1,1), \n  Y=NA\n)\n\n# Add orders\nfp$StdOrder <- 1:nrow(fp)\nfp$RunOrder <- sample(nrow(fp))\nfp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   A  B  C  Y StdOrder RunOrder\n1 -1 -1 -1 NA        1        7\n2  1 -1 -1 NA        2        1\n3 -1  1 -1 NA        3        8\n4  1  1 -1 NA        4        2\n5 -1 -1  1 NA        5        3\n6  1 -1  1 NA        6        6\n7 -1  1  1 NA        7        5\n8  1  1  1 NA        8        4\n```\n\n\n:::\n:::\n\n\nThen save it (typ. as CSV), perform the experiments, fill the `Y` yield column, and load it back for the analysis\n\n::: aside\n{{< bi info-circle >}} In a **replicated** $k\\cdot2^n$ FP, the replica index is formally just another factor with $k$ levels\n:::\n\n\n## Simple example in vanilla R\n\nFor a fractional factorial plan, we reject one half of the FP according to a **defining relationship**: $I=ABC$, which can be transformed as $C=AB$ **{{< bi bookmark-fill >}}**\n\nWe remove rows where the sign of $C$ is the product of $A$ and $B$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the fraction where C=AB\nffp <- fp[fp$C==fp$A*fp$B, ]\n\n# Add orders\nfp$StdOrder <- 1:nrow(fp)\nffp$RunOrder <- sample(nrow(ffp))\nffp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   A  B  C  Y StdOrder RunOrder\n2  1 -1 -1 NA        2        3\n3 -1  1 -1 NA        3        4\n5 -1 -1  1 NA        5        2\n8  1  1  1 NA        8        1\n```\n\n\n:::\n:::\n\n\nBut mind you! for this to work, columns `A`, `B`, and `C` **must NOT be [factors]{.ul}!** (in the R sense)\n\n:::{.callout-note icon=false}\n## {{< bi bookmark-fill >}} Remark on defining relationships\nIt holds the signs algebra: $X\\cdot X=I,~I\\cdot X = X$, thus $CI = ABCC~\\rightarrow~C=AB$\n:::\n\n::: aside\n{{< bi info-circle >}} When factors become numerous, and when you need to fraction two or three or more times, the above operations become cumbersome and error prone\n:::\n\n\n## Simple example in vanilla R\n\nAnalyzing the FP is mostly a matter of:\n\n* defining a linear model, `Y~A*B*C`\n* using `lm()` to fit the model\n* using `residuals()` to check the residuals for normality and patterns\n* using `anova()` to analyze the model\n* simplify the model if necessary\n\nBut if the FP is **non-replicated**, you can't fit a model unless you remove some terms from the general linear model `Y~A*B*C`. To do so, Daniel's method suggests to make a [Q-Q plot of the effects]{.bblue}: **not straightforward** \n\n\n## Simple example in vanilla R\n\nAs an example for a $2^4$ FP, the Daniel's Q-Q plot of the effects can be obtained by:\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# build a full linear model:\nfp.lm <- lm(Y ~ A*B*C*D, data=fp)\n\n# prepare plot data:\nlen     <- length(fp.lm$effects)\neffects <- fp.lm$effects[2:len]\n\n# Q-Q plot:\nqq      <- qqnorm(effects)\nqqline(effects)\n\n# add names:\ntext(qq$x, qq$y, labels=names(effects))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-4-1.png){width=1500}\n:::\n:::\n\n\n::: aside\n**{{< bi exclamation-diamond >}} Problems**: not immediate; the plot is not really clean and it often needs tuning (scales and labels size)\n:::\n\n## Simple example in vanilla R\n\n{{< bi exclamation-diamond >}} Problems:\n\n::: columns\n:::{.column width=66%}\n* difficult to manage **scaled units** *vs.* non scaled units\n* factor names aren't **mnemonic** (which parameter is represented by `F`?)\n* **fractioning** an FP is not trivial\n* **Daniel's method** is tricky and repetitive\n* **augmenting a plan** is not trivial when the number of factors is 4 or more\n* everything is not very **tidy** (in the sense of [tidyverse]{.bgreen})\n:::\n\n:::{.column width=34%}\n![](https://www.tidyverse.org/css/images/hex/ggplot2.png){width=60% fig-align=center}\n:::\n:::\n\n## Enter `adas.utils` package\n\nThe package is available on CRAN:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"adas.utils\")\nlibrary(adas.utils)\n```\n:::\n\n\nDon't forget to look at the vignette:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvignette(\"adas.utils\")\n```\n:::\n\n\n\n\n## Plain FPs\n\nBase $2\\cdot 2^2$ FP:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(adas.utils)\n\n# Two factors, two replicas\nfp_design_matrix(2, rep=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factorial Plan Design Matrix\n Defining Relationship:  ~ A * B \n Factors:  A B \n Levels:  -1 1 \n Fraction:  NA \n Type:  plain \n \n# A tibble: 8 Ã— 7\n  StdOrder RunOrder .treat  .rep     A     B Y    \n     <int>    <int> <chr>  <int> <dbl> <dbl> <lgl>\n1        1        5 (1)        1    -1    -1 NA   \n2        2        6 a          1     1    -1 NA   \n3        3        3 b          1    -1     1 NA   \n4        4        1 ab         1     1     1 NA   \n5        5        7 (1)        2    -1    -1 NA   \n6        6        4 a          2     1    -1 NA   \n7        7        8 b          2    -1     1 NA   \n8        8        2 ab         2     1     1 NA   \n```\n\n\n:::\n:::\n\n\n::: callout-note\nNote the Yates' treatment names in `.treat` column\n:::\n\n::: aside\n{{< bi info-circle >}} The object returned, class `factorial.plan`, is a `tibble` with added attributes that keep track of the design\n:::\n\n\n## Plain FPs, with named factors\n\nWe can tie factors with corresponding parameter names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two factors, two replicas, with names\nfp_design_matrix(2, rep=2) %>% \n  fp_add_names(\n    A=\"Temperature\", \n    B=\"Pressure\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factorial Plan Design Matrix\n Defining Relationship:  ~ A * B \n Factors:  A B \n Levels:  -1 1 \n Fraction:  NA \n Type:  plain \n Factor names:\n    A: Temperature\n    B: Pressure\n \n# A tibble: 8 Ã— 7\n  StdOrder RunOrder .treat  .rep     A     B Y    \n     <int>    <int> <chr>  <int> <dbl> <dbl> <lgl>\n1        1        1 (1)        1    -1    -1 NA   \n2        2        5 a          1     1    -1 NA   \n3        3        4 b          1    -1     1 NA   \n4        4        2 ab         1     1     1 NA   \n5        5        3 (1)        2    -1    -1 NA   \n6        6        6 a          2     1    -1 NA   \n7        7        7 b          2    -1     1 NA   \n8        8        8 ab         2     1     1 NA   \n```\n\n\n:::\n:::\n\n\n::: aside\n{{< bi info-circle >}} Note that it's been designed to support the `magrittr` pipe operator `%>%` (or the native R one `|>`)\n:::\n\n\n## Plain FPs, with named factors and actual scales\n\nActual scales can be added for reference:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two factors, two replicas, with names and scales\nfp_design_matrix(2, rep=2) %>% \n  fp_add_names(\n    A=\"Temperature\", \n    B=\"Pressure\"\n  ) %>% \n  fp_add_scale(\n    A=c(20, 25), \n    B=c(75, 125), \n    suffix=\".scaled\"\n  ) %>% \n  # Just to keep output compact ðŸ˜Ž \n  select(-c(StdOrder, RunOrder))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factorial Plan Design Matrix\n Defining Relationship:  ~ A * B \n Factors:  A B \n Levels:  -1 1 \n Fraction:  NA \n Type:  plain \n Scales suffix: .scaled\n Scaled factors:\n    A.scaled: [20, 25]\n    B.scaled: [75, 125]\n Factor names:\n    A: Temperature\n    B: Pressure\n \n# A tibble: 8 Ã— 7\n  .treat  .rep     A     B A.scaled B.scaled Y    \n  <chr>  <int> <dbl> <dbl>    <dbl>    <dbl> <lgl>\n1 (1)        1    -1    -1       20       75 NA   \n2 a          1     1    -1       25       75 NA   \n3 b          1    -1     1       20      125 NA   \n4 ab         1     1     1       25      125 NA   \n5 (1)        2    -1    -1       20       75 NA   \n6 a          2     1    -1       25       75 NA   \n7 b          2    -1     1       20      125 NA   \n8 ab         2     1     1       25      125 NA   \n```\n\n\n:::\n:::\n\n\n::: aside\n{{< bi info-circle >}} Note that it's been designed to support the `magrittr` pipe operator `%>%` (or the native R one `|>`)\n:::\n\n\n## Augmented FPs\n\nWe can augment a $2^n$ FP with a **central treatment**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Three factors, scaled\nfp_design_matrix(3) %>%\n  fp_add_scale(B=c(10, 20)) %>% \n  \n  # Augment with a central treatment\n  fp_augment_center(rep=4) %>% \n  \n  # Just to keep output compact ðŸ˜Ž \n  slice_tail(n=6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factorial Plan Design Matrix\n Defining Relationship:  ~ A * B * C \n Factors:  A B C \n Levels:  -1 1 \n Fraction:  NA \n Type:  centered \n Scales suffix: _s\n Scaled factors:\n    B_s: [10, 20]\n \n# A tibble: 6 Ã— 9\n  StdOrder RunOrder .treat  .rep     A     B     C   B_s Y    \n     <int>    <int> <chr>  <int> <dbl> <dbl> <dbl> <dbl> <lgl>\n1        7        5 bc         1    -1     1     1    20 NA   \n2        8        6 abc        1     1     1     1    20 NA   \n3        9       12 center     1     0     0     0    15 NA   \n4       10        9 center     2     0     0     0    15 NA   \n5       11       10 center     3     0     0     0    15 NA   \n6       12       11 center     4     0     0     0    15 NA   \n```\n\n\n:::\n:::\n\n\n\n## Augmented FPs\n\nAnd then further augment the FP with **axial treatments** to get a rotatable *Composite Centered Design* (CCD):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(2) %>%\n  fp_add_scale(\n    A=c(7,18), \n    B=c(10, 20)) %>%\n  fp_augment_center(rep=1) %>%\n  # Also augment with axial treatments\n  fp_augment_axial(rep=1) %>% \n  # Just to keep output compact ðŸ˜Ž \n  select(-RunOrder) %>% \n  as_tibble() # don't print header\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 Ã— 8\n  StdOrder .treat  .rep     A     B   A_s   B_s Y    \n     <int> <chr>  <int> <dbl> <dbl> <dbl> <dbl> <lgl>\n1        1 (1)        1 -1    -1     7    10    NA   \n2        2 a          1  1    -1    18    10    NA   \n3        3 b          1 -1     1     7    20    NA   \n4        4 ab         1  1     1    18    20    NA   \n5        5 center     1  0     0    12.5  15    NA   \n6        6 axial      1  0    -1.41 12.5   7.93 NA   \n7        7 axial      1 -1.41  0     4.72 15    NA   \n8        8 axial      1  1.41  0    20.3  15    NA   \n9        9 axial      1  0     1.41 12.5  22.1  NA   \n```\n\n\n:::\n:::\n\n\n:::{.callout-note}\nAutomatically scaling CCDs helps a lot in correctly defining process settings for each treatment\n:::\n\n::: aside\n{{< bi info-circle >}} Converted to a tibble to reduce the printout length\n:::\n\n\n## Augmented FPs\n\nAnd then further augment the FP with **axial treatments** to get a rotatable *Centered Composite Design* (CCD):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(2) %>%\n  fp_add_scale(\n    A=c(7,18), \n    B=c(10, 20)) %>%\n  fp_augment_center(rep=1) %>%\n  fp_augment_axial(rep=1) %>% \n  \n  # Make a plot\n  ggplot(aes(x=A, y=B)) + \n  geom_circle(aes(x0=0, y0=0, r=sqrt(2)), \n              lty=2, color=gray(0.5)) +\n  geom_label(aes(label=.treat)) +\n  theme(legend.position = \"bottom\") + \n  coord_fixed(xlim=c(-1.5,1.5) * 6/4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-12-1.png){width=1800}\n:::\n:::\n\n\n:::{.callout-note}\nOf course it works on higher dimensions as well\n:::\n\n\n\n\n## Fractional Factorial Plans\n\nWe can fraction a $2^n$ FP by adding subsequent **defining relationships**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(5) %>% \n  fp_fraction(~A*B*C*D) %>% \n  fp_fraction(~B*C*D*E) %>% \n  select(-c(StdOrder, RunOrder, .rep)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factorial Plan Design Matrix\n Defining Relationship:  ~ A * B * C * D * E \n Factors:  A B C D E \n Levels:  -1 1 \n Fraction:  I=ABCD I=BCDE \n Type:  fractional \n \n# A tibble: 8 Ã— 9\n  .treat     A     B     C     D     E Y      ABCD  BCDE\n  <chr>  <dbl> <dbl> <dbl> <dbl> <dbl> <lgl> <dbl> <dbl>\n1 (1)       -1    -1    -1    -1    -1 NA        1     1\n2 bc        -1     1     1    -1    -1 NA        1     1\n3 bd        -1     1    -1     1    -1 NA        1     1\n4 cd        -1    -1     1     1    -1 NA        1     1\n5 abe        1     1    -1    -1     1 NA        1     1\n6 ace        1    -1     1    -1     1 NA        1     1\n7 ade        1    -1    -1     1     1 NA        1     1\n8 abcde      1     1     1     1     1 NA        1     1\n```\n\n\n:::\n:::\n\n\n## Save design matrix\n\nYou can save the design matrix as CSV file (for collecting experimental data), then load it back **into** the original FP object (thus preserving attributes):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp <- fp_design_matrix(4) %>% \n  fp_fraction(~A*B*C*D) %>% \n  fp_write_csv(\"fp.csv\")\n\nfp <- fp %>% \n  fp_read_csv(\"fp.csv\")\n\nfp %>% select(-RunOrder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factorial Plan Design Matrix\n Defining Relationship:  ~ A * B * C * D \n Factors:  A B C D \n Levels:  -1 1 \n Fraction:  I=ABCD \n Type:  fractional \n \n# A tibble: 8 Ã— 9\n  StdOrder .treat  .rep     A     B     C     D Y      ABCD\n     <int> <chr>  <int> <dbl> <dbl> <dbl> <dbl> <lgl> <dbl>\n1        1 (1)        1    -1    -1    -1    -1 NA        1\n2        4 ab         1     1     1    -1    -1 NA        1\n3        6 ac         1     1    -1     1    -1 NA        1\n4        7 bc         1    -1     1     1    -1 NA        1\n5       10 ad         1     1    -1    -1     1 NA        1\n6       11 bd         1    -1     1    -1     1 NA        1\n7       13 cd         1    -1    -1     1     1 NA        1\n8       16 abcd       1     1     1     1     1 NA        1\n```\n\n\n:::\n:::\n\n\n::: callout-note\nThe saved CSV file has a commented header with FFP details (e.g. defining relationships, factors names, scales, etc.)\n:::\n\n\n## Alias structures\n\nFractioning a FP creates **alias structures**: the `adas.utils` package can help you with that too:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_alias_matrix(~A*B*C, ~B*C*D)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDefining relationships:\n I=ABC I=BCD I=AD \n\n     A B AB C AC BC ABC D AD BD ABD CD ACD BCD ABCD\nA    0 0  0 0  0  1   0 3  0  0   0  0   0   0    2\nB    0 0  0 0  1  0   0 0  0  0   3  2   0   0    0\nAB   0 0  0 1  0  0   0 0  0  3   0  0   2   0    0\nC    0 0  1 0  0  0   0 0  0  2   0  0   3   0    0\nAC   0 1  0 0  0  0   0 0  0  0   2  3   0   0    0\nBC   1 0  0 0  0  0   0 2  0  0   0  0   0   0    3\nABC  0 0  0 0  0  0   0 0  2  0   0  0   0   3    0\nD    3 0  0 0  0  2   0 0  0  0   0  0   0   0    1\nAD   0 0  0 0  0  0   2 0  0  0   0  0   0   1    0\nBD   0 0  3 2  0  0   0 0  0  0   0  0   1   0    0\nABD  0 3  0 0  2  0   0 0  0  0   0  1   0   0    0\nCD   0 2  0 0  3  0   0 0  0  0   1  0   0   0    0\nACD  0 0  2 3  0  0   0 0  0  1   0  0   0   0    0\nBCD  0 0  0 0  0  0   3 0  1  0   0  0   0   0    0\nABCD 2 0  0 0  0  3   0 1  0  0   0  0   0   0    0\n```\n\n\n:::\n:::\n\n\n\n## Alias structures\n\nThe alias matrix can be plotted directly, via `ggplot2`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_alias_matrix(~A*B*C, ~B*C*D) %>% \n  plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-16-1.png){width=1800}\n:::\n:::\n\n\n::: callout-note\nThe third generator is the **dependent one**, i.e. the one that has all terms not in common in the first two generators\n:::\n\n\n## Daniel's method\n\nThe `adas.utils` package can also help you with **Daniel's method**: the `daniel_plot_hn()` function takes a linear model object and returns a half-normal plot of the effects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltration %>% \n  lm(Y~A*B*C*D, data=.) %>%\n  daniel_plot_hn(nlab=6, repel=TRUE) +\n  labs(title=\"Revised model: Y~A*C + A*D\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-17-1.png){width=1500}\n:::\n:::\n\n\n\n## Pareto chart of the effects\n\nIt's easy to build a Pareto chart of the effects in a linear model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltration %>% \n  lm(Y~A*B*C*D, data=.) %>%\n  pareto_chart() +\n  theme(\n    legend.position = \"bottom\",\n    axis.text.x = \n      element_text(angle=45, hjust=1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-18-1.png){width=1500}\n:::\n:::\n\n\n\n## Tukey plots\n\nTukey's test `TukeyHSD()` is not compatible with `ggplot2`, and its output pretty limited (and not very appealing). The `adas.utils` package provides a `ggTukey()` function that can be used to plot the results of Tukey's test, **also with multiple groups**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbattery %>%\n  ggTukey(Response~Material, \n          splt=~Temperature, \n          conf.level=0.99)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-19-1.png){width=1800}\n:::\n:::\n\n\n::: aside\n{{< bi info-circle >}} `ggTukey()` is a **generic** with two methods: `ggTukey.data.frame()` and `ggTukey.TukeyHSD()`\n:::\n\n## Alternatives?\n\nOnly **pre-tidyverse** packages as:\n\n* `DoE.base`\n* `FrF2`\n\n\n\n## Future developments\n\n* `adas.utils` is currently `v1.2.0` on CRAN\n  * {{< bi terminal >}} `install.packages(\"adas.utils\")`\n* Development version on GitHub `v1.2.1`\n  * {{< bi terminal >}} `devtools::install_github(\"pbosetti/adas.utils\")`\n* The package is open to contributions **{{< bi github >}}**\n* Currently working on:\n  - a tool that suggests [minimum aberration designs]{.bgreen} for FFPs $2^{n-p}$ where $p\\geq 2$\n  - blocking structures\n\n::: aside\n**{{< bi github >}}** Development on: [github.com/pbosetti/adas.utils](https://github.com/pbosetti/adas.utils)\n:::\n\n# {{< bi person-raised-hand >}} Question time\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}