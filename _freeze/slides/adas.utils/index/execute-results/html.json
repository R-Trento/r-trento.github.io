{
  "hash": "f6e5adcc96dc987a3809c93b9630b68b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The `adas.utils` package\"\nsubtitle: \"Design of Experiments, the tidy way\"\nauthor: Paolo Bosetti\ninstitute: University of Trento\ntitle-slide-attributes:\n  data-background-image: /images/logo.png\n  data-background-size: 20%\n  data-background-position: top center\n  data-background-repeat: no-repeat\ndraft: true\ncategories: [packages, meeting]\nformat: \n  revealjs:\n    width: 1280\n    height: 720\n    margin: 0.1\n    slide-number: true\n    output-location: column\n    code-line-numbers: true\n    code-annotations: below\n    preview-links: auto\n    theme: [default, ../slides.scss]\n    chalkboard: true\n    footer: \"RTUG --- [https://rtug.unitn.it/slides.html](/slides.html)\"\n    fig-width: 5\n    fig-height: 4\n    fig-dpi: 300\n    touch: true\n    email-obfuscation: javascript\n    pdf-separate-fragments: true\n    link-external-icon: true\n    lang: it-IT\nabstract: |\n  We are here presenting the `adas.utils` package, a collection of functions for the design of experiments, the tidy way.\n---\n\n\n\n\n# Contents\n\n::: columns\n:::{.column width=66%}\n* Design of Experiments (*DoE*) and factorial plans\n* How to do DoE in vanilla R\n* How to do DoE with the `adas.utils` package\n* Alternatives\n* Future developments\n:::\n\n:::{.column width=33%}\n![](/posts/004-adas.utils/hypercube.jpg)\n:::\n:::\n\n## Design of Experiments and factorial plans\n\n::: columns\n:::{.column width=66%}\n* Design of Experiments (*DoE*) is a collection of statistical techniques to plan and analyze **industrial** experiments\n* Predictors are typically many (10 or more), and can be continuous or categorical\n* Often a first-order model is enough\n* Fitting a **response surface** on a multidimensional grid can be costly\n\nDoE aims at getting the [most information]{.bgreen} from a [minimum of experiments]{.bblue}\n:::\n\n:::{.column width=34%}\n![](https://m.media-amazon.com/images/I/81zdcVeRwRL._SY385_.jpg){width=80% fig-align=center}\n:::\n:::\n\n::: aside\nSee the famous \"Design and Analysis of Experiments\", by Douglas C. Montgomery, 10th edition, Wiley, 2020. \n:::\n\n## DoE in brief\n\n::: columns\n:::{.column width=66%}\n* Plan for a grid of treatments (*factorial plan*) in the $n$-hyperspace, where $n$ is the number of predictors, or **process parameters**\n* The FP can be optimized, sacrificing completeness for efficiency (*Fractional Factorial Plans*)\n* The FP must be [randomized]{.bgreen}, to reduce bias due to systematic errors\n* The FP can be [non-replicated]{.bgreen}, to further reduce costs (*Daniel's method*)\n* The FP can be [augmented]{.bgreen}, to add new treatments to an existing plan (*Augmented Factorial Plans*)\n* We use [coded units]{.bgreen} (i.e. normalized to $[-1,1]$)\n:::\n\n:::{.column width=34%}\n![](CCD2.png){width=60% fig-align=center}\n\n![](CCD3.png){width=60% fig-align=center}\n:::\n:::\n\n\n## Simple example in vanilla R\n\nCreate a non-replicated **full factorial plan** with three factors, two levels each ($2^3$):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp <- expand.grid(\n  A=c(-1,1), \n  B=c(-1,1), \n  C=c(-1,1), \n  Y=NA\n)\nfp$StdOrder <- 1:nrow(fp)\nfp$RunOrder <- sample(nrow(fp))\nfp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   A  B  C  Y StdOrder RunOrder\n1 -1 -1 -1 NA        1        6\n2  1 -1 -1 NA        2        7\n3 -1  1 -1 NA        3        2\n4  1  1 -1 NA        4        5\n5 -1 -1  1 NA        5        3\n6  1 -1  1 NA        6        8\n7 -1  1  1 NA        7        1\n8  1  1  1 NA        8        4\n```\n\n\n:::\n:::\n\n\nThen save it (typ. as CSV), perform the experiments, fill the `Y` yield column, and load it back for the analysis\n\n::: aside\nIn a **replicated** $k\\cdot2^n$ FP, the replica index is formally just another factor with $k$ levels\n:::\n\n\n## Simple example in vanilla R\n\nFor a fractional factorial plan, we reject one half of the FP according to a **defining relationship**: $I=ABC$, which can be transformed as $C=AB$.\n\nWe remove rows where the sign of $C$ is the product of $A$ and $B$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nffp <- fp[fp$C==fp$A*fp$B, ]\nffp$RunOrder <- sample(nrow(ffp))\nffp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   A  B  C  Y StdOrder RunOrder\n2  1 -1 -1 NA        2        2\n3 -1  1 -1 NA        3        4\n5 -1 -1  1 NA        5        3\n8  1  1  1 NA        8        1\n```\n\n\n:::\n:::\n\n\nBut mind you! for this to work, columns `A`, `B`, and `C` **must NOT be factors!**\n\n::: aside\nWhen factors become numerous, and when you need to fraction two or three or more times, the above operations become cumbersome and error prone\n:::\n\n\n## Simple example in vanilla R\n\nAnalyzing the FP is mostly a matter of:\n\n* defining a linear model, `Y~A*B*C`\n* using `lm()` to fit the model\n* using `residuals()` to check the residuals for normality and patterns\n* using `anova()` to analyze the model\n* simplify the model if necessary\n\nBut if the FP is **non-replicated**, you can't fit a model unless you remove some terms from the general linear model `Y~A*B*C`. To do so, Daniel's method suggests to make a [Q-Q plot of the effects]{.bblue}: **not straightforward** \n\n## Simple example in vanilla R\n\nA Q-Q plot of the effects can be obtained by:\n\n\n## Simple example in vanilla R\n\nProblems:\n\n* difficult to manage **scaled units** *vs.* non scaled units\n* factor names aren't **menmonic**\n* **fractioning** an FP is not trivial\n* **Daniel's method** is tricky and repetitive\n* **augmenting a plan** is not trivial when the number of factors is 4 or more\n\n## `adas.utils` package\n\n\n## Alternatives?\n\n\n## Future developments\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}