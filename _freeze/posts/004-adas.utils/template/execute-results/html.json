{
  "hash": "df642198a31520d6b3a272940d7452c3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introducing the `adas.utils` package\"\nauthor: \"Paolo Bosetti\"\ndate: \"02/10/2025\"\n# date-modified: today\nimage: \"image.jpg\"\nformat: html\ndraft: false\ncategories: \n  - packages\n  - R\n  - design of experiments\nabstract: >\n  The package `adas.utils`, contributed by one of RTUG members, aims at helping in the design and analysis of factorial experiments.\n---\n\n\n\n\n\n\n# Factorial plans\n\nThe package provides tools for dealing with factorial plan according to the *Design of Experiments* (DoE) protocols. The functions for dealing with DoE have names starting with `fp_`. As much as possible, we are aiming at a tidyverse-like syntax, so that the functions can be used in a pipe.\n\nWe are following conventions and techniques illustrated in the book *Design and Analysis of Experiments* by Douglas C. Montgomery.\n\n## Full factorial plan\n\nYou can create a full factorial plan with the `fp_design_matrix` function, passing the number of factors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(dm <- fp_design_matrix(2, rep=2) %>% \n  mutate(Y=rnorm(n())))\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B \n#>  Factors:  A B \n#>  Levels:  -1 1 \n#>  Fraction:  NA \n#>  Type:  plain \n#>  \n#> # A tibble: 8 × 7\n#>   StdOrder RunOrder .treat  .rep     A     B       Y\n#>      <int>    <int> <chr>  <int> <dbl> <dbl>   <dbl>\n#> 1        1        7 (1)        1    -1    -1 -0.0404\n#> 2        2        8 a          1     1    -1  0.157 \n#> 3        3        5 b          1    -1     1  0.469 \n#> 4        4        1 ab         1     1     1  1.98  \n#> 5        5        6 (1)        2    -1    -1 -1.10  \n#> 6        6        3 a          2     1    -1 -0.706 \n#> 7        7        4 b          2    -1     1  0.321 \n#> 8        8        2 ab         2     1     1 -0.143\n```\n:::\n\n\n\nIn this case, the factors are the first `n` capital letters.\n\nIf you want different factor names, use a right-side-only formula combining all the named factors with `*`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(~Speed*Weight)\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ Speed * Weight \n#>  Factors:  Speed Weight \n#>  Levels:  -1 1 \n#>  Fraction:  NA \n#>  Type:  plain \n#>  \n#> # A tibble: 4 × 7\n#>   StdOrder RunOrder .treat       .rep Speed Weight Y    \n#>      <int>    <int> <chr>       <int> <dbl>  <dbl> <lgl>\n#> 1        1        3 (1)             1    -1     -1 NA   \n#> 2        2        2 speed           1     1     -1 NA   \n#> 3        3        1 weight          1    -1      1 NA   \n#> 4        4        4 speedweight     1     1      1 NA\n```\n:::\n\n\n\n**NOTE**, though, that using custom factor names is discouraged, and won't work as expected if you are using the functions for dealing with **fractional factorial plans**, especially for the analysis of alias structures among factors.\n\nThe yield column `Y` must then be completed according to the randomized `RunOrder` column.\n\nIt is possible to add custom scales to the factors, and also add names to the factors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(2) %>% \n  fp_add_names(A=\"Temperature\", B=\"Pressure\") %>%\n  fp_add_scale(A=c(20, 25), B=c(75, 125), suffix=\".scaled\")\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B \n#>  Factors:  A B \n#>  Levels:  -1 1 \n#>  Fraction:  NA \n#>  Type:  plain \n#>  Scaled factors:\n#>     A: [20, 25]\n#>     B: [75, 125]\n#>  Factor names:\n#>     A: Temperature\n#>     B: Pressure\n#>  \n#> # A tibble: 4 × 9\n#>   StdOrder RunOrder .treat  .rep     A     B A.scaled B.scaled Y    \n#>      <int>    <int> <chr>  <int> <dbl> <dbl>    <dbl>    <dbl> <lgl>\n#> 1        1        1 (1)        1    -1    -1       20       75 NA   \n#> 2        2        3 a          1     1    -1       25       75 NA   \n#> 3        3        4 b          1    -1     1       20      125 NA   \n#> 4        4        2 ab         1     1     1       25      125 NA\n```\n:::\n\n\n\n\n## Custom levels\n\nIf you want a $k^n$ factorial plan with custom levels, pass the `levels` argument. In this case, though, the `.treat` column with Yates' treatment codes would be `NA`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(2, levels=-1:1)\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B \n#>  Factors:  A B \n#>  Levels:  -1 0 1 \n#>  Fraction:  NA \n#>  Type:  plain \n#>  \n#> # A tibble: 9 × 6\n#>   StdOrder RunOrder  .rep     A     B Y    \n#>      <int>    <int> <int> <int> <int> <lgl>\n#> 1        1        5     1    -1    -1 NA   \n#> 2        2        7     1     0    -1 NA   \n#> 3        3        1     1     1    -1 NA   \n#> 4        4        6     1    -1     0 NA   \n#> 5        5        9     1     0     0 NA   \n#> 6        6        4     1     1     0 NA   \n#> 7        7        2     1    -1     1 NA   \n#> 8        8        3     1     0     1 NA   \n#> 9        9        8     1     1     1 NA\n```\n:::\n\n\n\n\n## Augment a plan\n\nYou can augment a plan by adding a central point, typically repeated:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(3) %>%\n  fp_augment_center(rep=4)\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B * C \n#>  Factors:  A B C \n#>  Levels:  -1 1 \n#>  Fraction:  NA \n#>  Type:  centered \n#>  \n#> # A tibble: 12 × 8\n#>    StdOrder RunOrder .treat  .rep     A     B     C Y    \n#>       <int>    <int> <chr>  <int> <dbl> <dbl> <dbl> <lgl>\n#>  1        1        1 (1)        1    -1    -1    -1 NA   \n#>  2        2        5 a          1     1    -1    -1 NA   \n#>  3        3        4 b          1    -1     1    -1 NA   \n#>  4        4        6 ab         1     1     1    -1 NA   \n#>  5        5        2 c          1    -1    -1     1 NA   \n#>  6        6        8 ac         1     1    -1     1 NA   \n#>  7        7        3 bc         1    -1     1     1 NA   \n#>  8        8        7 abc        1     1     1     1 NA   \n#>  9        9        9 center     1     0     0     0 NA   \n#> 10       10       11 center     2     0     0     0 NA   \n#> 11       11       12 center     3     0     0     0 NA   \n#> 12       12       10 center     4     0     0     0 NA\n```\n:::\n\n\n\nThen if needed (because the analysis show low p-value for the quadratic term) you can add axial points to get a central composite design:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(3) %>% \n  fp_augment_center(rep=3) %>% \n  fp_augment_axial(rep=2)\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B * C \n#>  Factors:  A B C \n#>  Levels:  -1 1 \n#>  Fraction:  NA \n#>  Type:  composite \n#>  \n#> # A tibble: 35 × 8\n#>    StdOrder RunOrder .treat  .rep     A     B     C Y    \n#>       <int>    <int> <chr>  <int> <dbl> <dbl> <dbl> <lgl>\n#>  1        1        2 (1)        1    -1    -1    -1 NA   \n#>  2        2        3 a          1     1    -1    -1 NA   \n#>  3        3        7 b          1    -1     1    -1 NA   \n#>  4        4        4 ab         1     1     1    -1 NA   \n#>  5        5        1 c          1    -1    -1     1 NA   \n#>  6        6        6 ac         1     1    -1     1 NA   \n#>  7        7        8 bc         1    -1     1     1 NA   \n#>  8        8        5 abc        1     1     1     1 NA   \n#>  9        9       10 center     1     0     0     0 NA   \n#> 10       10       11 center     2     0     0     0 NA   \n#> # ℹ 25 more rows\n```\n:::\n\n\n\n### Full example\n\nLet's see a full example using the `ccd_experiment_yield` dataset, which contains a list of the yield data for three sequential experiments in a central composite design.\n\nFirst, we design a $3\\cdot 2^2$ factorial plan, with two factors and two levels each:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp <- fp_design_matrix(2, rep=3)\n```\n:::\n\n\n\nIdeally, we would then sort the table according to the `RunOrder` column, and complete the `Y` column with the yield data from the the real experiments. For the sake of documenting the package, we can directly add the yield data from the `base` field of the `ccd_experiment_yield` dataset (which holds values **in standard Yates' order**):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp$Y <- ccd_experiment_yield$base\n```\n:::\n\n\n\nNow we can fit a linear model to the data, and check the p-values of the ANOVA:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp %>% \n  lm(Y ~ A*B, data=.) %>% \n  anova()\n#> Analysis of Variance Table\n#> \n#> Response: Y\n#>           Df  Sum Sq Mean Sq F value    Pr(>F)    \n#> A          1  49.331  49.331  105.06 7.058e-06 ***\n#> B          1 131.224 131.224  279.46 1.659e-07 ***\n#> A:B        1 216.931 216.931  461.99 2.311e-08 ***\n#> Residuals  8   3.756   0.470                      \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\nAll factors and their interactions are significant. But is the two-level model enough? Let's check for the quadratic terms, by augmenting the plan with a central point repeated 4 times. We also load the `center` field from the `ccd_experiment_yield` dataset:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfpc <- fp %>% \n  fp_augment_center(rep=4)\n\nfpc$Y[fpc$.treat == \"center\"] <- ccd_experiment_yield$center\n```\n:::\n\n\n\nNow we can fit a model with the quadratic term, using either $A$ or $B$: since we only have a central point, we cannot discriminate which factor is contributing to the curvature in the response surface. We get:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfpc %>% \n  lm(Y ~ A*B+I(A^2), data=.) %>% \n  anova()\n#> Analysis of Variance Table\n#> \n#> Response: Y\n#>           Df  Sum Sq Mean Sq F value    Pr(>F)    \n#> A          1  49.331  49.331  96.801 8.695e-07 ***\n#> B          1 131.224 131.224 257.494 5.592e-09 ***\n#> I(A^2)     1  15.204  15.204  29.834 0.0001972 ***\n#> A:B        1 216.931 216.931 425.673 3.827e-10 ***\n#> Residuals 11   5.606   0.510                      \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\nSo the contribution of the quadratic term **is significant**. This means that we have to further augment the plan with axial points and investigate a *Central Composite Design* (CCD). **Note**: if the quadratic term contribution were not significant, we would have to remove the quadratic term from the model and accept the two-level model.\n\nSo let's load the axial points from the `axial` field of the `ccd_experiment_yield` dataset, and fit a model with the quadratic terms and their interactions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfpccd <- fpc %>% \n  fp_augment_axial(rep=2)\n\nfpccd$Y[fpccd$.treat == \"axial\"] <- ccd_experiment_yield$axial\n\nfpccd %>% \n  lm(Y ~ A*B*I(A^2)*I(B^2), data=.) %>% \n  anova()\n#> Analysis of Variance Table\n#> \n#> Response: Y\n#>               Df  Sum Sq Mean Sq  F value    Pr(>F)    \n#> A              1  75.196  75.196  94.1952 7.395e-08 ***\n#> B              1 194.702 194.702 243.8964 1.097e-10 ***\n#> I(A^2)         1 101.355 101.355 126.9638 1.017e-08 ***\n#> I(B^2)         1   3.551   3.551   4.4479   0.05216 .  \n#> A:B            1 216.931 216.931 271.7423 5.087e-11 ***\n#> A:I(A^2)       1   0.235   0.235   0.2945   0.59530    \n#> B:I(A^2)       1   1.046   1.046   1.3106   0.27022    \n#> I(A^2):I(B^2)  1   0.490   0.490   0.6142   0.44542    \n#> Residuals     15  11.974   0.798                       \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\nSo we can finally state that a proper model would be `Y ~ A*B+I(A^2)`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfpccd %>% \n  lm(Y ~ A*B+I(A^2), data=.) %>% \n  summary()\n#> \n#> Call:\n#> lm(formula = Y ~ A * B + I(A^2), data = .)\n#> \n#> Residuals:\n#>      Min       1Q   Median       3Q      Max \n#> -1.64925 -0.60624  0.00919  0.65165  1.67506 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept)   1.0156     0.3061   3.318  0.00362 ** \n#> A             1.9390     0.2134   9.088 2.40e-08 ***\n#> B             3.1201     0.2134  14.624 8.59e-12 ***\n#> I(A^2)        2.9905     0.2834  10.552 2.20e-09 ***\n#> A:B           4.2518     0.2754  15.437 3.32e-12 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.9541 on 19 degrees of freedom\n#> Multiple R-squared:  0.9714,\tAdjusted R-squared:  0.9654 \n#> F-statistic: 161.5 on 4 and 19 DF,  p-value: 2.191e-14\n```\n:::\n\n\n\n## Save to/load from a file\n\nOnce the design matrix is prepared, you typically want to save it to a file and use it for collecting data form experiments. You can use the `write.csv` function, but it is recommended to use the `fp_write_csv` function, which will also save the design matrix properties as comments:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm <-  fp_design_matrix(2) %>% \n  fp_add_names(A=\"Temperature\", B=\"Pressure\") %>% \n  fp_add_scale(A=c(2, 12), B=c(40, 60), suffix=\"_s\") %>%\n  fp_write_csv(\"design_matrix.csv\")\n```\n:::\n\n\n\nNote that the `fp_write_csv` function invisibly returns the same design matrix, so you can use it in a pipe chain. Also, the CVS files has the rows arranged in the same order as the `RunOrder` column (i.e. randomized). \n\nOnce the CSV file has been completed, you can load it back into R using the `fp_read_csv` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm <- dm %>% \n  fp_read_csv(\"design_matrix.csv\")\n```\n:::\n\n\n\nNote that `fp_read_csv` returns the design matrix reordered according to Yates' standard order.\n\n\n\n## Fractional factorial plan\n\nIt is possible to divide a design matrix into a fractional factorial plan using the `fp_fraction` function. The fraction uses a **defining relationship** (*dr*) as $I=ABCD$, which is mapped in R as a one side formula `~A*B*C*D`.\n\nAny fraction is added to the `factorial.plan` object in the `fraction` attribute.\n\nA full $2^n$ factorial plan can be reduced to a fractional factorial plan $2^{n-p}$ by applying the `fp_fraction` function $p$ times. For example, to get a $2^{5-2}$ plan with the defining relationships $I=ABCD$ and $I=BCDE$:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(5) %>% \n  fp_fraction(~A*B*C*D) %>% \n  fp_fraction(~B*C*D*E)\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B * C * D * E \n#>  Factors:  A B C D E \n#>  Levels:  -1 1 \n#>  Fraction:  I=ABCD I=BCDE \n#>  Type:  fractional \n#>  \n#> # A tibble: 8 × 12\n#>   StdOrder RunOrder .treat  .rep     A     B     C     D     E Y      ABCD  BCDE\n#>      <int>    <int> <chr>  <int> <dbl> <dbl> <dbl> <dbl> <dbl> <lgl> <dbl> <dbl>\n#> 1        1       29 (1)        1    -1    -1    -1    -1    -1 NA        1     1\n#> 2        7       10 bc         1    -1     1     1    -1    -1 NA        1     1\n#> 3       11       26 bd         1    -1     1    -1     1    -1 NA        1     1\n#> 4       13        4 cd         1    -1    -1     1     1    -1 NA        1     1\n#> 5       20       25 abe        1     1     1    -1    -1     1 NA        1     1\n#> 6       22       24 ace        1     1    -1     1    -1     1 NA        1     1\n#> 7       26       32 ade        1     1    -1    -1     1     1 NA        1     1\n#> 8       32       28 abcde      1     1     1     1     1     1 NA        1     1\n```\n:::\n\n\n\nNote that with the `remove` option you can control if you want to keep both fractions, and later on `filter(ABC==1)` them out.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfp_design_matrix(3) %>% \n  fp_fraction(~A*B*C, remove=FALSE)\n#>  Factorial Plan Design Matrix\n#>  Defining Relationship:  ~ A * B * C \n#>  Factors:  A B C \n#>  Levels:  -1 1 \n#>  Fraction:  I=ABC \n#>  Type:  fractional \n#>  \n#> # A tibble: 8 × 9\n#>   StdOrder RunOrder .treat  .rep     A     B     C Y       ABC\n#>      <int>    <int> <chr>  <int> <dbl> <dbl> <dbl> <lgl> <dbl>\n#> 1        1        4 (1)        1    -1    -1    -1 NA       -1\n#> 2        2        3 a          1     1    -1    -1 NA        1\n#> 3        3        6 b          1    -1     1    -1 NA        1\n#> 4        4        5 ab         1     1     1    -1 NA       -1\n#> 5        5        8 c          1    -1    -1     1 NA        1\n#> 6        6        2 ac         1     1    -1     1 NA       -1\n#> 7        7        7 bc         1    -1     1     1 NA       -1\n#> 8        8        1 abc        1     1     1     1 NA        1\n```\n:::\n\n\n\nAlso, note that the `remove` option is sticky, so that when you can apply the `fp_fraction` function multiple times and the first time has the option set to `remove=FALSE`, then all the following `fp_fraction` calls will have the same option set to `FALSE`. Setting `remove=FALSE` to any of the following calls **can have unexpected behavior**.\n\n\n## Alias structure\n\nAny fraction of a factorial plan results in a set of *aliases* among effects. The package provides the following functions to deal with alias structures:\n\n- `fp_alias_matrix`: returns a matrix with the alias structure of the factors in the design matrix. The alias matrix has a plot method.\n- `fp_all_drs`: given a set of defining relationships, returns the dependent one.\n- `fp_merge_drs`: given a set of defining relationships, returns the merged one, i.e. the one having all the factors.\n- `fp_gen2alias`: given a *generator* (i.e. the right side of a DR) and an effect name as strings, calculates the resulting alias.\n\nFor example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(am <- fp_alias_matrix(~A*B*C, ~B*C*D))\n#> Defining relationships:\n#>  I=ABC I=BCD I=AD \n#> \n#>      A B AB C AC BC ABC D AD BD ABD CD ACD BCD ABCD\n#> A    0 0  0 0  0  1   0 3  0  0   0  0   0   0    2\n#> B    0 0  0 0  1  0   0 0  0  0   3  2   0   0    0\n#> AB   0 0  0 1  0  0   0 0  0  3   0  0   2   0    0\n#> C    0 0  1 0  0  0   0 0  0  2   0  0   3   0    0\n#> AC   0 1  0 0  0  0   0 0  0  0   2  3   0   0    0\n#> BC   1 0  0 0  0  0   0 2  0  0   0  0   0   0    3\n#> ABC  0 0  0 0  0  0   0 0  2  0   0  0   0   3    0\n#> D    3 0  0 0  0  2   0 0  0  0   0  0   0   0    1\n#> AD   0 0  0 0  0  0   2 0  0  0   0  0   0   1    0\n#> BD   0 0  3 2  0  0   0 0  0  0   0  0   1   0    0\n#> ABD  0 3  0 0  2  0   0 0  0  0   0  1   0   0    0\n#> CD   0 2  0 0  3  0   0 0  0  0   1  0   0   0    0\n#> ACD  0 0  2 3  0  0   0 0  0  1   0  0   0   0    0\n#> BCD  0 0  0 0  0  0   3 0  1  0   0  0   0   0    0\n#> ABCD 2 0  0 0  0  3   0 1  0  0   0  0   0   0    0\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nam %>% plot()\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-19-1.png){width=100%}\n:::\n:::\n\n\n\nThe design matrix can be converted to a tibble thanks to the proper `as_tibble.design.matrix` S3 method:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nam %>% as_tibble()\n#> # A tibble: 42 × 3\n#>    Effect.x Effect.y generator\n#>    <chr>    <chr>    <chr>    \n#>  1 A        BC       ABC      \n#>  2 A        D        AD       \n#>  3 A        ABCD     BCD      \n#>  4 B        AC       ABC      \n#>  5 B        ABD      AD       \n#>  6 B        CD       BCD      \n#>  7 AB       C        ABC      \n#>  8 AB       BD       AD       \n#>  9 AB       ACD      BCD      \n#> 10 C        AB       ABC      \n#> # ℹ 32 more rows\n```\n:::\n\n\n\n\n\n# Statistics\n\nThe package also provides some useful functions for statistical analysis of data.\n\n## Plotting\n\n### Normal probability plot\n\nThe normal probability plot is provided as an alternative to the quantile-quantile plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  xn = rnorm(100, mean=20, sd=5),\n  xu = runif(100, min=0, max=40)\n)\n\ndf %>% normplot(xn)\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-21-1.png){width=100%}\n:::\n\n```{.r .cell-code}\ndf %>% normplot(xu)\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-21-2.png){width=100%}\n:::\n:::\n\n\n\n### Pareto chart\n\nThe Pareto chart is a bar chart that displays the relative importance of problems in a format that is very easy to interpret. The bars are sorted in descending order, and the cumulative percentage of the total is shown by the line.\n\nIt can prove useful in the context of factorial plans, to identify the most important factors, or in sensitivity analysis, to identify the most important parameters.\n\nThe package provides a *generic function*, `pareto_chart`, that can be used with a tibble (or a data frame), or with a linear model (an `lm` object). In the latter case, the function produces the Pareto chart of the model effects.\n\nFor the general case, when you have a tibble with values and names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\ntibble(\n  val=rnorm(10, sd=5),\n  cat=LETTERS[1:length(val)]\n  ) %>%\n  pareto_chart(labels=cat, values=val)\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-22-1.png){width=100%}\n:::\n:::\n\n\n\nFor the case of a linear model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltration %>% \n  lm(Y~A*B*C*D, data=.) %>%\n  pareto_chart()\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-23-1.png){width=100%}\n:::\n:::\n\n\n\n### Daniel's plot\n\nIn case of non-replicated factorial plans, the Daniel's plot can be used to identify the most important factors: a quantile-quantile plot of the factors effects shows the significant factors and interactions off the diagonal.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaniel_plot_qq(lm(Y~A*B*C*D, data=filtration))\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-24-1.png){width=100%}\n:::\n:::\n\n\n\nIf you prefer, you can rather use a half-normal plot:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltration %>% \n  lm(Y~A*B*C*D, data=.) %>%\n  daniel_plot_hn(nlab=6, repel=TRUE)\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-25-1.png){width=100%}\n:::\n:::\n\n\n\n\nIt shows that none of the effects containing the `B` factor are significant, so we can reduce the model to `Y~A*C*D`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltration %>% \n  lm(Y~A*C*D, data=.) %>%\n  anova()\n#> Analysis of Variance Table\n#> \n#> Response: Y\n#>           Df  Sum Sq Mean Sq F value    Pr(>F)    \n#> A          1 1870.56 1870.56 83.3677 1.667e-05 ***\n#> C          1  390.06  390.06 17.3844 0.0031244 ** \n#> D          1  855.56  855.56 38.1309 0.0002666 ***\n#> A:C        1 1314.06 1314.06 58.5655 6.001e-05 ***\n#> A:D        1 1105.56 1105.56 49.2730 0.0001105 ***\n#> C:D        1    5.06    5.06  0.2256 0.6474830    \n#> A:C:D      1   10.56   10.56  0.4708 0.5120321    \n#> Residuals  8  179.50   22.44                      \n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n\n\n\nEven better, the model can be further reduced to `Y~A*C+A*D`. Compare this conclusion with the last Pareto chart above.\n\n\n# Utilities\n\nThis package also provides a function for easily loading data files made available on the accompanying course documentation on <https://paolobosetti.quarto.pub/data>:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexamples_url(\"battery.dat\") %>%  read.table(header=TRUE)\n#>    RunOrder StandardOrder Temperature Material Repeat Response\n#> 1        34             1          15        1      1      130\n#> 2        25             2          70        1      1       34\n#> 3        16             3         125        1      1       20\n#> 4         7             4          15        2      1      150\n#> 5         8             5          70        2      1      136\n#> 6         1             6         125        2      1       25\n#> 7        26             7          15        3      1      138\n#> 8        36             8          70        3      1      174\n#> 9         6             9         125        3      1       96\n#> 10       13            10          15        1      2      155\n#> 11        3            11          70        1      2       40\n#> 12       31            12         125        1      2       70\n#> 13       27            13          15        2      2      188\n#> 14       29            14          70        2      2      122\n#> 15       12            15         125        2      2       70\n#> 16       14            16          15        3      2      110\n#> 17       30            17          70        3      2      120\n#> 18       24            18         125        3      2      104\n#> 19        5            19          15        1      3       74\n#> 20       21            20          70        1      3       80\n#> 21       10            21         125        1      3       82\n#> 22       35            22          15        2      3      159\n#> 23       19            23          70        2      3      106\n#> 24       28            24         125        2      3       58\n#> 25       18            25          15        3      3      168\n#> 26       20            26          70        3      3      150\n#> 27       33            27         125        3      3       82\n#> 28       11            28          15        1      4      180\n#> 29       23            29          70        1      4       75\n#> 30       17            30         125        1      4       58\n#> 31       15            31          15        2      4      126\n#> 32       32            32          70        2      4      115\n#> 33        4            33         125        2      4       45\n#> 34       22            34          15        3      4      160\n#> 35        2            35          70        3      4      139\n#> 36        9            36         125        3      4       60\n```\n:::\n\n\n\n\n\n\n:::thatsall\nThat's all, folks!\n:::",
    "supporting": [
      "template_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}