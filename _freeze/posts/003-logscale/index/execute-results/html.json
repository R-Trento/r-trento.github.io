{
  "hash": "e4ff37c8e764056c8ca84500a2a0df67",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Logarithmic scales in GGPlot2\"\nauthor: \"Paolo Bosetti\"\ndate: \"02/09/2025\"\n# date-modified: today\nimage: \"steps.jpg\"\nformat: html\ndraft: false\ncategories: \n  - post\n  - R\n  - tidyverse\n  - GGPlot2\n  - signal analysis\nabstract: >\n  With the excuse of doing signal analysis in R, this post discusses on how to deal with logarithmic scalses and tick-marks in GGPlot2, and how to generate log-spaced grids to have an equally dense set of points in the resulting plot.\nengine: knitr\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Rationale\n\nRecently I had to port in R some Matlab code using the `tf` and `bode` functions, which are respectively used to calculate the transfer function and create a Bode plot of it.\n\nThe R package `control` luckily provides the analogous functions, although its `control::bodeplot` function uses the base `plot` interface. Of course, I wanted to make an analogous plot with GGplot2 tools.\n\n# Example: vibration isolation\n\nLet us use the example for a lumped parameters model of a vibration isolation system, that is, a 1-DoF mass-spring-damper system. Briefly, its transfer function can be created as:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- 10\nK <- 1000\nC <- 50\n\n(H <- tf(c(C/K, 1),c(M/K, C/K, 1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\ny1:\n        0.05 s^1 + 1 \n  - - - - - - - - - - - - -\n    0.01 s^2 + 0.05 s + 1 \n\n\nTransfer Function: Continuous time model \n```\n\n\n:::\n:::\n\n\n\nIts Bode representation can be obtained by:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbode(H) %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ w    : num [1:10000] 0 0.01 0.02 0.03 0.04 ...\n $ mag  : num [1:10000] 0.00 8.69e-06 3.48e-05 7.82e-05 1.39e-04 ...\n $ phase: num [1:10000] 0.00 -2.87e-08 -2.29e-07 -7.74e-07 -1.83e-06 ...\n```\n\n\n:::\n:::\n\n\n\nThat is, a list of three vectors reporting frequency (`w`), magnitude in dB (`mag`), and phase in degrees (`phase`). Why the `control` developers decided to return a list of equally sized vectors rather a data frame is beyond me, but let's deal with what we have.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbode(H, w=1:1e4) %>% {\n  tibble(\n    `frequency (rad/s)` = .$w, \n    `magnitude (dB)` = .$mag,\n    `phase (deg)` = .$phase\n  )\n} %>% \n  head() %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| frequency (rad/s)| magnitude (dB)| phase (deg)|\n|-----------------:|--------------:|-----------:|\n|                 1|      0.0870762|  -0.0288644|\n|                 2|      0.3509189|  -0.2362699|\n|                 3|      0.7993794|  -0.8294252|\n|                 4|      1.4452744|  -2.0825653|\n|                 5|      2.3044892|  -4.3987054|\n|                 6|      3.3880407|  -8.4155907|\n\n\n:::\n:::\n\n\n\nTo make the Bode plot, which reports magnitude vs. frequency on top of phase vs. frequency, we make the tibble tidy and use `facet_wrap`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbode(H, w=1:1e4) %>% {\n  tibble(\n    `frequency (rad/s)` = .$w, \n    `magnitude (dB)` = .$mag,\n    `phase (deg)` = .$phase\n  )\n} %>%\n  pivot_longer(-`frequency (rad/s)`) %>% \n  ggplot(aes(x=`frequency (rad/s)`, y=value)) +\n  geom_line() +\n  geom_point(alpha = 0.2) +\n  facet_wrap(~name, nrow=2, scales=\"free\") +\n  scale_x_log10()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nNote the followings:\n\n1. in `facet_wrap`, we use the option `scales=\"free\"`: this allows to independently rescale the axes of each facet;\n2. the horizontal axis is logarithmic, but there is only one secondary grid line, while we usually have secondary gridlines at 2, 3, ..., 9;\n3. the point density is not evenly spaced on the logarithmic axis.\n\nSo, here we want to tackle the problems in 2. and 3..\n\n# Log-tickmarks: Solution\n\nThe `scale_x_log10()` function allows to specify the `breaks` and the `minor_breaks`, which we can exploit to fix the gridlines. How can we get a log-spaced sequence? an elegant solution uses the **outer product** `%o%` of two vectors: that of the ticks, and that of the orders of magnitude (`ooms`):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nticks <- 2:9\nooms <- 10^seq(0, 4)\n\nticks %o% ooms\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]  [,5]\n[1,]    2   20  200 2000 20000\n[2,]    3   30  300 3000 30000\n[3,]    4   40  400 4000 40000\n[4,]    5   50  500 5000 50000\n[5,]    6   60  600 6000 60000\n[6,]    7   70  700 7000 70000\n[7,]    8   80  800 8000 80000\n[8,]    9   90  900 9000 90000\n```\n\n\n:::\n:::\n\n\nLooking at the columns , in sequence, we have what we want, so:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(breaks <- as.vector(ticks %o% ooms))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]     2     3     4     5     6     7     8     9    20    30    40    50\n[13]    60    70    80    90   200   300   400   500   600   700   800   900\n[25]  2000  3000  4000  5000  6000  7000  8000  9000 20000 30000 40000 50000\n[37] 60000 70000 80000 90000\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbode(H, w=1:1e4) %>% {\n  tibble(\n    `frequency (rad/s)` = .$w, \n    `magnitude (dB)` = .$mag,\n    `phase (deg)` = .$phase\n  )\n} %>%\n  pivot_longer(-`frequency (rad/s)`) %>% \n  ggplot(aes(x=`frequency (rad/s)`, y=value)) +\n  geom_line() +\n  geom_point(alpha = 0.2) +\n  facet_wrap(~name, nrow=2, scales=\"free\") +\n  scale_x_log10(minor_breaks=breaks, labels=scales::scientific)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nBingo!\n\nNow, we still have too sparse points to the left, and **definitely too many points to the right**. We can use a similar approach to define the frequency vector.\n\n\n# Log-spaced points: Solution\n\nWe use the same outer product trick, multiplying the vector of orders of magnitude by a vector of positions, **exponentially spaced** within each magnitude:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npts <- 10^seq(0, 1, 0.1) %>% tail(-1)\n(freqs <- as.vector(pts %o% ooms)) %>% head(n=20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1.258925   1.584893   1.995262   2.511886   3.162278   3.981072\n [7]   5.011872   6.309573   7.943282  10.000000  12.589254  15.848932\n[13]  19.952623  25.118864  31.622777  39.810717  50.118723  63.095734\n[19]  79.432823 100.000000\n```\n\n\n:::\n:::\n\n\n\nFinally:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npts <- 10^seq(0, 1, 0.01) %>% tail(-1)\nfreqs <- as.vector(pts %o% ooms)\n\nbode(H, w=freqs) %>% {\n  tibble(\n    `frequency (rad/s)` = .$w, \n    `magnitude (dB)` = .$mag,\n    `phase (deg)` = .$phase\n  )\n} %>%\n  pivot_longer(-`frequency (rad/s)`) %>% \n  ggplot(aes(x=`frequency (rad/s)`, y=value)) +\n  geom_line() +\n  geom_point(alpha = 0.2) +\n  facet_wrap(~name, nrow=2, scales=\"free\") +\n  scale_x_log10(minor_breaks=breaks, labels=scales::scientific)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\n# Putting all together\n\nWe can then put everything together and make a useful function (note that we are now converting the frequencies to Hz):\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggbodeplot <- function(tf, fmin=1, fmax=1e4, df=0.01) {\n  ticks <- 2:9\n  pts <- 10^seq(0, 1, df) %>% tail(-1)\n  ooms <- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  breaks <- as.vector(ticks %o% ooms)\n  freqs <- as.vector(pts %o% ooms)\n  \n  bode(tf, freqs*2*pi) %>% {\n    tibble(f=.$w/(2*pi), `magnitude (dB)`=.$mag, `phase (deg)`=.$phase)} %>% \n    pivot_longer(-f) %>% \n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(minor_breaks=breaks, labels=scales::scientific) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"frequency (Hz)\")\n}\n\nH %>% ggbodeplot(fmin=0.1, fmax=100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\n# One last thing...\n\nWell, the above is mostly of academic interest, at least for what pertains the logarithmic grid lines: it shows a nice and useful way for creating regularly spaced vectors, which is really useful to evenly distribute abscissa values when the axis scale is not linear. But thanks to the `scales` package there is a quick way for having **any axis, whichever the scale**, with a number of minor breaks different to 1 (the defaiult in GGplot). In fact, we can just use the `scales::minor_breaks_n()` function to generate minor grid lines at will:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggbodeplot <- function(tf, fmin=1, fmax=1e4, df=0.01) {\n  pts <- 10^seq(0, 1, df) %>% tail(-1)\n  ooms <- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  freqs <- as.vector(pts %o% ooms)\n  \n  bode(tf, freqs*2*pi) %>% {\n    tibble(f=.$w/(2*pi), `magnitude (dB)`=.$mag, `phase (deg)`=.$phase)} %>% \n    pivot_longer(-f) %>% \n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(\n      minor_breaks=scales::minor_breaks_n(10), \n      labels= ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))\n    ) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"frequency (Hz)\")\n}\n\nH %>% ggbodeplot(fmin=0.1, fmax=100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nwhere the trick is to set `scale_x_log10(minor_breaks=scales::minor_breaks_n(10))`. Note that the argument is the **number of intervals** rather than the number of grid lines (so, 10 rather than 9). As a final suggestion, try and use the same command with a `scale_x_continuous`: it works whichever is the axis transformation (including identity). Also, note the `labels` lambda function used for formatting tick labels.\n\n:::thatsall\nThat's all, folks!\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}