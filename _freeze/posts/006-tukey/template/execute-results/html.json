{
  "hash": "9b1322e50e35aa48c779874eb710a124",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tukey's test plot in `adas.utils`\"\nauthor: \"Paolo Bosetti\"\ndate: \"03/27/2025\"\n# date-modified: today\nimage: \"Tukey.jpg\"\nformat: html\ndraft: false\ncategories: \n  - R\n  - packages\nabstract: >\n  The new version 1.1.1 of the `adas.utils` package includes a new function to plot the results of Tukey's test.\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Rationale\n\nThe new version v1.1.1 of the `adas.utils` package includes a new function to plot the results of Tukey's test. The function is called `ggTukey` and it is used to plot the results of Tukey's test provided by the `stas::TukeyHSD` function.\n\n:::{.column-margin}\n![John W. Tukey](Tukey.jpg)\n:::\n\nThe standard `stats::TukeyHSD` function returns an S3 object that has the `print` and `plot` methods. The result of the `plot` method, though, is honestly not really appealing. Let's see how it works, by loading a dataset and running a Tukey's test on it. We load an online dataset by using the `adas.utils::examples_url` function[^1], and we begin with a simple boxplot of the data.\n\n[^1]: This function can load any data file listed on <https://paolobosetti.quarto.pub/data>\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(adas.utils)\n\ndata <- examples_url(\"anova.dat\") %>% \n  read.table(header=TRUE) %>% \n  mutate(Cotton=factor(Cotton)) %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 25\nColumns: 3\n$ Cotton      <fct> 15, 15, 15, 15, 15, 20, 20, 20, 20, 20, 25, 25, 25, 25, 25…\n$ Observation <int> 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5…\n$ Strength    <int> 7, 7, 15, 11, 9, 12, 17, 12, 18, 18, 14, 18, 18, 19, 19, 1…\n```\n\n\n:::\n\n```{.r .cell-code}\ndata %>% \n  ggplot(aes(x=Cotton, y=Strength, group=Cotton)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-1-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nThe Tukey's test is built by using the `aov` function and the `TukeyHSD` function. The results are then plotted by the `plot` method of the `TukeyHSD` object:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata %>% \n  aov(Strength ~ Cotton, data=.) %>%\n  TukeyHSD() %>% \n  plot()\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nThe biggest problem with `plot.TukeyHSD` is that the labels of the differences are often partially hidden if there are many groups or the plot is too squat. This is the main reason for implementing an analogous function based on GGplot2 in `adas.utils`.\n\n# Enter `ggTukey`\n\nLabels are much more readable in the `ggTukey` plot. Let's see how it works:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata %>% \n  aov(Strength ~ Cotton, data=.) %>%\n  TukeyHSD() %>% \n  ggTukey()\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nThere's actually more: you can also pass to `ggTukey` the data frame and the formula to be used in the `aov` model:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata %>% \n  ggTukey(Strength ~ Cotton)\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-4-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nWhich is nicely more tidiverse-y and readable, isn't it?\n\nNow let's look at a different, slightly more complex dataset:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata <- examples_url(\"battery.dat\") %>% \n  read.table(header=TRUE) %>% \n  mutate(Material=factor(LETTERS[Material]), Temperature=factor(Temperature)) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 36\nColumns: 6\n$ RunOrder      <int> 34, 25, 16, 7, 8, 1, 26, 36, 6, 13, 3, 31, 27, 29, 12, 1…\n$ StandardOrder <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1…\n$ Temperature   <fct> 15, 70, 125, 15, 70, 125, 15, 70, 125, 15, 70, 125, 15, …\n$ Material      <fct> A, A, A, B, B, B, C, C, C, A, A, A, B, B, B, C, C, C, A,…\n$ Repeat        <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,…\n$ Response      <int> 130, 34, 20, 150, 136, 25, 138, 174, 96, 155, 40, 70, 18…\n```\n\n\n:::\n:::\n\n\n\nThis one shows discharge test results for batteries with different dielectric materials (qualitative factors) and operating at different temperatures (quantitative factors). So inn this case we have two predictors. We want to create a set of Tukey's tests for each level of `Material`. We need to pass `ggTukey` with the formula `Response ~ Temperature` (for the `aov` model) and the `splt` argument with another, one side formula that specifies the grouping factor: `~Material`. In a terse and clear way, we can write:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata %>% \n  ggTukey(Response ~ Temperature, splt=~Material)\n```\n\n::: {.cell-output-display}\n![](template_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=16cm}\n:::\n:::\n\n\n\nAnd that was not possible with the standard `plot.TukeyHSD` method, at least not in two lines of code.\n\n::: thatsall\nThat's all, folks!\n:::\n",
    "supporting": [
      "template_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}